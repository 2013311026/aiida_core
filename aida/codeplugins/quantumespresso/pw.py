"""
Plugin to create a Quantum Espresso pw.x file.

TODO: many cards missing
TODO: implement if_pos
TODO: implement pre_... and post_... hooks to add arbitrary strings before
      and after a namelist, and a 'final_string' (all optional); useful 
      for development when new cards are needed
"""
from aida.codeplugins.exceptions import InputValidationError
from aida.common.classes.structure import Sites
from aida.common.utils import get_suggestion
from aida.codeplugins.quantumespresso import (
    conv_to_fortran, get_input_data_text)
from aida.common.utils import get_unique_filename
from aida.repository.structure import get_sites_from_uuid
from aida.repository.potential import get_potential_from_uuid
import os

# List of namelists (uppercase) that are allowed to be found in the
# input_data, in the correct order
_compulsory_namelists = ['CONTROL', 'SYSTEM', 'ELECTRONS']

# List of cards (uppercase) that are allowed to be found in the
# input_data. 'atomic_species', 'atomic_positions' not allowed since they
# are automatically generated by the plugin
#_allowed_cards = ['K_POINTS', 'CONSTRAINTS', 'OCCUPATIONS']

# This is used to set the if_pos value in the ATOMIC_POSITIONS card
#_further_allowed = ['BLOCKED_COORDS']

_calc_types_noionscells = ['scf','nscf','bands']
_calc_types_onlyions = ['relax', 'md']
_calc_types_bothionscells = ['vc-relax', 'vc-md']


def create_calc_input(calc, work_folder):
    """
    Create the necessary input files in work_folder for calculation calc.

    Note: for the moment, it requires that flags are provided lowercase,
        while namelists/cards are provided uppercase.
    
    Args:
        calc: the calculation object for which we want to create the 
            input file.
        work_folder: the folder where we want to create the files. Should
            be a aida.common.classes.folder.Folder object.

    Returns:
        a dictionary with the following keys:
            retrieve_output: a list of files, directories or patterns to be
                retrieved from the cluster scratch dir and copied in the
                permanent aida repository.
            cmdline_params: a (possibly empty) string with the command line
                parameters to pass to the code.
            stdin: a string with the file name to be used as standard input,
                or None if no stdin redirection is required. 
                Note: if you want to pass a string, create a file with the 
                string and use that file as stdin.
            stdout: a string with the file name to which the standard output
                should be redirected, or None if no stdout redirection is
                required. 
            stderr: a string with the file name to which the standard error
                should be redirected, or None if no stderr redirection is
                required. 
            preexec: a (possibly empty) string containing commands that may be
                required to be run before the code executes.
            postexec: a (possibly empty) string containing commands that may be
                required to be run after the code has executed.

    TODO: this function should equally work if called from the API client or
        from within django. To check/implement! May require some work

    TODO: options to set cmdline_params

    TODO: decide whether to return a namedtuple instead of a dict
        (see http://docs.python.org/2/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields )
    """
    PSEUDO_SUBFOLDER = './pseudo'
    
    retdict = {}
    retdict['retrieve_output'] = ['aida.out', 'out/data-file.xml'] 
    retdict['cmdline_params'] = "" # possibly -npool and similar
    retdict['stdin'] = 'aida.in'
    retdict['stdout'] = 'aida.out'
    retdict['stderr'] = None
    retdict['preexec'] = ""
    retdict['postexec'] = ""

    input_filename = work_folder.get_filename(retdict['stdin'])

    # I get input parameters
    try:
        input_data = calc.get_input_data()
        input_params = input_data.pop('input_params')
    except Exception as e:
        import traceback
        print traceback.format_exc()
        raise InputValidationError('Unable to retrieve the input data. '
                                   'I got exception "{}" with message: '
                                   '{}'.format(str(type(e)), e.message))

    # get_input_sites returns a list, I check that I have only
    # one input site and then I save it in input_site
    input_structures = input_data.pop('structure_list',[])
    if len(input_structures) != 1:
        raise InputValidationError('One and only one input structure can be '
            'attached to a QE pw.x calculation. '
            'You provided {} structures instead.'.format(len(input_structures)))
    input_site_uuid = input_structures[0]
    input_site = get_sites_from_uuid(input_site_uuid)

    input_potentials_uuid = input_data.pop('potential_list',[])
    
    input_potentials = [get_potential_from_uuid(p) for p in 
                        input_potentials_uuid]


    # ============ I prepare the input site data =============
    # ------------ CELL_PARAMETERS -----------
    cell_parameters_card = "CELL_PARAMETERS angstrom\n"
    for vector in input_site.cell:
        cell_parameters_card += ("{0:18.10f} {1:18.10f} {2:18.10f}"
                                 "\n".format(*vector))

    # ------------- ATOMIC_SPECIES ------------
    specie_names, specie_indices = zip(*input_site.get_types())
    first_specie_sites = tuple(input_site.sites[sp_idx[0]] for
                               sp_idx in specie_indices)
    if len(specie_names) != len(input_potentials):
        raise InputValidationError('The number of provided pseudopotentials '
            'in the potential_list variable is different from the number of '
            'species of the input structure.')
    for i, (pot, site) in enumerate(zip(input_potentials, first_specie_sites)):
        if set(site.symbols) != pot.get_element_set():
            pot_el_str = ",".join(sorted(list(pot.get_element_set())))
            site_el_str = ",".join(sorted(site.symbols))
            errstr = ('Different set of elements for the '
                'potential at position {:d} and the corresponding atom: ({}) '
                'vs. ({})'.format(i+1, pot_el_str, site_el_str))
            raise InputValidationError(errstr)

    # I create the subfolder that contains the pseudopotentials
    pseudo_folder = work_folder.get_subfolder(PSEUDO_SUBFOLDER,create=True)

    # Will contain the filenames of the pseudopotentials (may not be exactly
    # the ones used in the repository due to name collisions)
    potential_filenames = []

    # I copy the potential files in the suitable subfolder.
    # .. todo:: change in so that it works also on the client side.
    for pot in input_potentials:
        pot_repo_folder = pot.get_repo_folder()
        # I get all filenames, excluding those starting with a dot
        # (I also exclude subfolders by using i[1]==True)
        pot_file_list = [i[0] for i in 
                         pot_repo_folder.get_content_list(pattern='[!.]*') 
                         if i[1]]
        if len(pot_file_list) != 1:
            raise InputValidationError(
                "The potential folder on the AIDA repository "
                "contains {:d} files, while I can manage only 1 file for "
                "Quantum Espresso.".format(len(pot_file_list)))
        # I create a unique filename. This is only the file name
        pot_file = get_unique_filename(pot_file_list[0],
                                       potential_filenames)

        # The path to the pseudo folder within the calculation in the
        # repository. I must set the correct RELATIVE symlink!
        final_pseudo_subdir = calc.get_repo_inputs_folder().get_subfolder(
            PSEUDO_SUBFOLDER)
        relative_path = os.path.relpath(pot_repo_folder.get_filename(pot_file),
                                        start=final_pseudo_subdir.abspath)
        pseudo_folder.create_symlink(src=relative_path, name=pot_file)
        potential_filenames.append(pot_file)

    atomic_species_card_list = ["ATOMIC_SPECIES\n"]
    for specie_name, first_specie_site, pot_name in zip(
        specie_names, first_specie_sites, potential_filenames):
        atomic_species_card_list.append("{} {} {}\n".format(
                specie_name.ljust(6), first_specie_site.mass, pot_name))
    atomic_species_card = "".join(atomic_species_card_list)

    # ------------ ATOMIC_POSITIONS -----------
    atomic_positions_card_list = ["ATOMIC_POSITIONS angstrom\n"]
    # TODO: implement if_pos
    for idx, site in enumerate(input_site.sites):
        if site.is_alloy() or site.has_vacancies():
            raise InputValidationError("The {}-th site is an alloy or has "
                "vacancies. This is not allowed for pw.x input structures.")
        # In the current version, max length of the specie name is 3. We do 
        # ljust(6) for formatting purposes, but note that ljust never trims
        # the string
        atomic_positions_card_list.append(
            "{0} {1:18.10f} {2:18.10f} {3:18.10f}\n".format(
                site.type.ljust(6), *site.position))
    atomic_positions_card = "".join(atomic_positions_card_list)

    # ============ I prepare the k-points =============
    try:
        k_points = input_params['K_POINTS']
    except KeyError: 
        raise InputValidationError("No K_POINTS specified.")

    try:
        k_points_type = k_points['type']
    except KeyError: 
        raise InputValidationError("No 'type' specified in K_POINTS card.")
    
    if k_points_type != "gamma":
        try:
            k_points_list = k_points["points"]
            num_k_points = len(k_points_list)
        except KeyError:
            raise InputValidationError("'K_POINTS' does not contain a 'points' "
                                       "key")
        except TypeError:
            raise InputValidationError("'points' key is not a list")
        if num_k_points == 0:
            raise InputValidationError("At least one k point must be "
                "provided for non-gamma calculations")

    k_points_card = "K_POINTS {}\n".format(k_points_type)

    if k_points_type == "automatic":
        if len(k_points_list) != 6:
            raise InputValidationError("k_points type is automatic, but "
                "'points' is not a list of 6 integers")
        try: 
            k_points_card += ("{:d} {:d} {:d} {:d} {:d} {:d}\n"
                             "".format(*k_points_list))
        except ValueError:
            raise InputValidationError("Some elements  of the 'points' key "
                "in the K_POINTS card are not integers")
            
    elif k_points_type == "gamma":
        # nothing to be written in this case
        pass
    else:
        k_points_card += "{:d}\n".format(num_k_points)
        try:
            if all(len(i)==4 for i in k_points_list):
                for kpoint in k_points_list:
                    k_points_card += ("  {:18.10f} {:18.10f} {:18.10f} {:18.10f}"
                        "\n".format(kpoint))
            else:
                raise InputValidationError("points must either all have "
                    "length four (3 coordinates + last value: weight)")
        except (KeyError, TypeError):
            raise InputValidationError("'points' must be a list of k points, "
                "each k point must be provided as a list of 4 items: its "
                "coordinates and its weight")


    # =================== NAMELISTS AND CARDS ========================
    try:
        control_nl = input_params['CONTROL']
        calculation_type = control_nl['calculation']
    except KeyError as e:
        raise InputValidationError("No 'calculation' in CONTROL namelist.")
            
    if calculation_type in _calc_types_noionscells:
        namelists_toprint = _compulsory_namelists
    elif calculation_type in _calc_types_bothionscells:
        namelists_toprint = _compulsory_namelists + ['IONS', 'CELL']
    elif calculation_type in _calc_types_onlyions:
        namelists_toprint = _compulsory_namelists + ['IONS']
    else:
        sugg_string = get_suggestion(calculation_type,
                                     _calc_types_noionscells + 
                                     _calc_types_onlyions + 
                                     _calc_types_bothionscells)
        raise InputValidationError("Unknown 'calculation' value in "
                                   "CONTROL namelist {}".format(sugg_string))
 
    # TODO: set default/forced values

    with open(input_filename,'w') as infile:
        for namelist in namelists_toprint:
            infile.write("&{0}\n".format(namelist.upper()))           
            # namelist content
            try:
                for k, v in sorted(input_params[namelist].iteritems()):
                    infile.write(get_input_data_text(k,v))
            except KeyError:
                # namelist not explicitly mentioned in input_data:
                # leave it empty
                pass
            infile.write("/\n")

        # Write cards now
        infile.write(atomic_species_card)
        infile.write(atomic_positions_card)
        infile.write(k_points_card)
        infile.write(cell_parameters_card)
        #TODO: write CONSTRAINTS
        #TODO: write OCCUPATIONS

    # Todo: either consume remaining input_data keys, or print warning

    return retdict

